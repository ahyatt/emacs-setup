#+auto_tangle: t
* Headers
#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src
* Bootstrapping
Let's start by making sure we have MELPA stable, which is a
requirement for a lot that follows.

Code comes from http://melpa.org/#/getting-started.
#+BEGIN_SRC emacs-lisp
(require 'package)
(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives (cons "gnu" (concat proto "://elpa.gnu.org/packages/")))))
(package-initialize)
#+END_SRC

We use use-package so before first running, install this with `package-install`.

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

Finally, let's switch to the straight vesion of use-package, so everything is
consistent (otherwise straight could be trying to use packages that overlap with
the ELPA packages that use-package straight).

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+end_src

* Better defaults

Most of this is taken from
https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#bootstrap.

I also prefer a minimal UI.
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)                           ; Disable the cursor blinking
(scroll-bar-mode 0)                             ; Disable the scroll bar
(tool-bar-mode 0)                               ; Disable the tool bar
(tooltip-mode 0) ; Disable the tooltips
#+END_SRC

Various better variable defaults & other basic defaults, mostly from
the same file.

#+BEGIN_SRC emacs-lisp
(setq-default
 ad-redefinition-action 'accept                   ; Silence warnings for redefinition
 auto-window-vscroll nil                          ; Lighten vertical scroll
 bookmark-save-flag 1                             ; Always save bookmarks
 compilation-ask-about-save nil                   ; Don't save anything, don't ask
 compilation-save-buffers-predicate '(lambda () nil)
 confirm-kill-emacs 'yes-or-no-p                  ; Confirm before exiting Emacs
 completion-cycle-threshold 5                     ; Tab-cycle completions if there are only 5 of them.
 completions-detailed t                           ; Add extra detail to completions
 cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
 column-number-mode t                             ; Useful to look out for line length limits
 delete-by-moving-to-trash t                      ; Delete files to trash
 display-time-default-load-average nil            ; Don't display load average
 display-time-format "%H:%M"                      ; Format the time string
 fill-column 80                                   ; Set width for automatic line breaks
 help-window-select t                             ; Focus new help windows when opened
 indent-tabs-mode nil                             ; Stop using tabs to indent
 inhibit-startup-screen t                         ; Disable start-up screen
 initial-scratch-message ""                       ; Empty the initial *scratch* buffer
 left-margin-width 1 right-margin-width 1         ; Add left and right margins
 mouse-yank-at-point t                            ; Yank at point rather than pointer
 next-error-message-highlight t                   ; Highlight the current error in next-error buffer.
 ns-use-srgb-colorspace nil                       ; Don't use sRGB colors
 reb-re-syntax 'string                            ; No double blacklashes in re-builder
 recenter-positions '(5 top bottom)               ; Set re-centering positions
 redisplay-dont-pause t                           ; As recommended by Mastering Emacs
 scroll-conservatively most-positive-fixnum       ; Always scroll by one line.
 scroll-margin 10                                 ; Add a margin when scrolling vertically
 select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
 sentence-end-double-space nil                    ; End a sentence after a dot and a space
 show-trailing-whitespace nil                     ; Display trailing whitespaces
 split-height-threshold nil                       ; Disable vertical window splitting
 split-width-threshold nil                        ; Disable horizontal window splitting
 tab-first-completion 'word                       ; Complete unless we're in the middle of the word.
 tab-always-indent 'complete                      ; If we're already indented, tab should complete
 tab-width 4                                      ; Set width for tabs
 tooltip-use-echo-area t                          ; Good for non-mouse-users
 use-dialog-box nil                               ; Never use a UI dialog box, only minibuffer
 use-short-answers t                              ; Use y/n instead yes / no.
 uniquify-buffer-name-style 'forward              ; Uniquify buffer names
 window-combination-resize t                      ; Resize windows proportionally
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width
(cd "~/")                                         ; Move to the user directory
(delete-selection-mode 1)                         ; Replace region when inserting text
(display-time-mode 1)                             ; Enable time in the mode-line
(fringe-mode 0)                                   ; Disable fringes
(global-subword-mode 1)                           ; Iterate through CamelCase words
(global-so-long-mode 1)                           ; Better performance for files with long lines
(menu-bar-mode 0)                                 ; Disable the menu bar
(mouse-avoidance-mode 'banish)                    ; Avoid collision of mouse with point
(put 'downcase-region 'disabled nil)              ; Enable downcase-region
(put 'upcase-region 'disabled nil)                ; Enable upcase-region
(set-default-coding-systems 'utf-8)               ; Default to utf-8 encoding
#+END_SRC

Enable fullscreen (emacs uber alles).

#+BEGIN_SRC emacs-lisp
(if (eq window-system 'ns)
    (toggle-frame-maximized)
  (toggle-frame-fullscreen))
#+END_SRC

Garbage-collect on focus-out, Emacs should feel snappier.

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

Also, I like using =ffap=.
#+begin_src emacs-lisp
(ffap-bindings)
#+end_src

Since this lisp is autogenerated, the output is write-only.  We need
customization to live in a different file.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC
** Input method
The TeX input method is really cool and super flexible, but I've been playing with the =rfc1345= which is a bit quicker and still very powerful.

See https://www.quae.nl/rfc1345.html for details.
#+begin_src emacs-lisp
(set-input-method "rfc1345")
#+end_src
** Backup defaults
#+begin_src emacs-lisp
(setq backup-directory-alist
      '(("." . "~/backups"))
      backup-by-copying t
      version-control t
      delete-old-versions t
      kept-new-versions 3
      kept-old-versions 2
      create-lockfiles nil)
#+end_src

* Useful additions
Tired of marking scripts executable, or forgetting to do so?  Now you don’t have to!
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

It's useful to have methods of getting the URLs (for Mac only)
#+begin_src emacs-lisp
(defun ash/get-current-url ()
  (do-applescript "tell application \"Google Chrome\" to return URL of active tab of front window"))
(defun ash/get-current-title ()
  (do-applescript "tell application \"Google Chrome\" to return Title of active tab of front window"))
#+end_src
* Packages
There's only one manual step in setting this all up - install -use-package-.

First, let's just make sure use-package works the way we want it to.

#+BEGIN_SRC emacs-lisp
  (setq-default use-package-always-ensure t)
  (require 'use-package)
#+END_SRC
** Helper packages
*** General
General is an easier way to do keybindings.
#+BEGIN_SRC emacs-lisp
(use-package general
  :config
  ;; Let's make the top-level key categories here
  (general-create-definer ash/key-def :prefix "C-c"))
#+END_SRC
** Org
This just loads the package, which we want to do before anything else ends up loading the default built-in org package.
#+BEGIN_SRC emacs-lisp
(use-package org
  :hook (org-mode . visual-line-mode)
  :config
  ;; TEMPORARY, seems like this isn't getting autoloaded correctly.
  (require 'org-duration)
  (require 'org-element)
  ;; A pomodoro group is for a day, so after 8 hours of no activity, that's a group.
  (setq org-pomodoro-expiry-time (* 60 8))
  :general
  ("C-c a" 'ash-goto-agenda)
  ("<f12>" 'org-capture)
  (:keymaps 'org-agenda-mode-map
            "P" 'org-pomodoro))
#+END_SRC
** Minibuffer customization
*** Completion
I've played around with a lot of different completion frameworks.  They all are
pretty good, but I like experimenting with new ideas, so this changes every so
often.

In general, the default completion isn't bad, but it often messes up due to
insisting on multi columns. Let's use =vertico=, although there's many good
choices. But =vertico= plays fairly nicely with the emacs completion system, which
is good for compatibility.
#+begin_src emacs-lisp
(use-package vertico
  :init
  (vertico-mode)
  (setq vertico-resize t
        vertico-cycle t))
#+end_src

Since the standard completion isn't that great (or maybe I haven't configured it
so well), let's also use =corfu= for in-buffer completions. In general, emacs
popups tend to misbehave, so let's see how this goes.
#+begin_src emacs-lisp
(use-package corfu
  :custom
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  (corfu-auto t)                 ;; Enable auto completion
  (corfu-separator ?\s)          ;; Orderless field separator
  (corfu-auto-delay 0.8)         ;; Pause a bit before completion, else it's annoying.

  ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
  ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
  :init
  (global-corfu-mode))
#+end_src

#+begin_src emacs-lisp
;; More completions
(use-package cape
  :config
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  (add-to-list 'completion-at-point-functions #'cape-abbrev)
  (add-to-list 'completion-at-point-functions #'cape-symbol)
  (add-to-list 'completion-at-point-functions #'cape-tex)
  (add-to-list 'completion-at-point-functions #'cape-rfc1345))

;; From Vertico example installation instructions.
(use-package orderless
  :custom
  (orderless-matching-styles '(orderless-regexp orderless-literal orderless-initialism orderless-prefixes))
  (orderless-component-separator " +\\|[-/]")
  :init
  ;; Completion category overrides for file helps with tramp, this is mentioned in the vertico docs.
  (setq completion-styles '(orderless)
        completion-ignore-case t
	    completion-category-defaults nil
	    completion-category-overrides '((file (styles basic partial-completion))))
  :config
  ;; We make the SPC key insert a literal space and the same for the
  ;; question mark.  Spaces are used to delimit orderless groups, while
  ;; the question mark is a valid regexp character.
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "SPC") nil)
    (define-key map (kbd "?") nil)))

(use-package savehist
  :init
  (savehist-mode))

(use-package marginalia
  :ensure t
  :config
  (marginalia-mode)
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))

;; A few more useful configurations...
(use-package emacs
  :init
  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
	'(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  (setq read-extended-command-predicate #'command-completion-default-include-p)

  ;; In non-programming-buffers, we don't want `pcomplete-completions-at-point'
  ;; or 't' which seems to complete everything.
  (defun ash/fix-completion-for-nonprog-buffers ()
    (setq completion-at-point-functions
          (-remove-item t (append (-remove-item #'pcomplete-completions-at-point completion-at-point-functions)
                                  '(cape-file cape-abbrev cape-rfc1345)))))
  (add-hook 'org-mode-hook #'ash/fix-completion-for-nonprog-buffers)
  (add-hook 'notmuch-message-mode-hook #'ash/fix-completion-for-nonprog-buffers)

  (setq enable-recursive-minibuffers t
        read-buffer-completion-ignore-case t
        read-file-name-completion-ignore-case t
        resize-mini-windows t))
#+end_src
*** Actions via embark
Embark is a framework for actions, including those done on completions.
#+begin_src emacs-lisp
(use-package embark
  :ensure t
  :bind
  (("s-a" . embark-act)
   ("s-A" . embark-act-noexit))
  :general
  (:keymaps 'embark-symbol-map
            "h" 'describe-symbol
            "t" 'trace-function
            "T" 'untrace-function
            "x" 'xref-find-references)
  :config
  (add-to-list 'marginalia-prompt-categories '("tab by name" . tab))
  (embark-define-keymap embark-tab-actions
    "Keymap for actions for tab-bar tabs (when mentioned by name)."
    ("s" tab-bar-select-tab-by-name)
    ("r" tab-bar-rename-tab-by-name)
    ("k" tab-bar-close-tab-by-name))
  (add-to-list 'embark-keymap-alist '(tab . embark-tab-actions))

  ;; By default, embark doesn't know how to handle org-links.  Let's provide a way.
  (defun ash/org-link ()
    "Get the link from an org-link."
    (require 's)
    (let ((context (org-element-context)))
      (cond ((and (eq (car context) 'link)
                  (equal (plist-get (cadr context) :type) "file"))
             (cons 'file (plist-get (cadr context) :path)))
            ((and (eq (car context) 'link)
                  (member (plist-get (cadr context) :type) '("http" "https")))
             (cons 'url (concat (plist-get (cadr context) :type) ":" (s-trim-right (plist-get (cadr context) :path)))))
            (t nil))))
  (add-to-list 'embark-target-finders 'ash/org-link))
#+end_src

Consult provides more mini-buffer search functionality
#+begin_src emacs-lisp
(use-package consult
  :config
  (add-hook 'completion-list-mode-hook #'consult-preview-at-point-mode))

(use-package embark-consult
  :ensure t
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook
  (embark-collect-mode . embark-consult-preview-minor-mode))
    
(use-package consult-flycheck
  :bind (:map flycheck-command-map
              ("!" . consult-flycheck))
  ;; If flycheck idle change delay is too short, then it overwrites the helpful
  ;; messages about how to call elisp functions, etc.
  :config (setq flycheck-idle-change-delay 15))

#+end_src
** Movement
*** Windows
CLOCK: [2020-07-17 Fri 20:04]--[2020-07-17 Fri 20:31] =>  0:27

Winnum for moving between windows is very convenient
#+BEGIN_SRC emacs-lisp
(use-package winum
  :config (winum-mode 1)
  :general
  ("M-1" 'winum-select-window-1)
  ("M-2" 'winum-select-window-2)
  ("M-3" 'winum-select-window-3)
  ("M-4" 'winum-select-window-4))
#+END_SRC
*** Jumping
Avy for quick jumping & buffer navigation is great.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :config
  (advice-add 'spacemacs/avy-goto-url :after (lambda () (browse-url-at-point)))
  (defun ash/avy-goto-url()
    "Use avy to go to an URL in the buffer."
    (interactive)
    ;; avy-action is a global that sometimes is stuck in a weird state, so we
    ;; have to specifically set it here via :action.
    (avy-jump "https?://" :action 'avy-action-goto)))
#+END_SRC
*** Key-based actions (hydra)
Hydra is useful for doing lots of things in succession.
#+BEGIN_SRC emacs-lisp
;; Before hydra because we use pretty-hydra-define in the hydra confg.
(use-package major-mode-hydra
  :bind
  ("M-o" . major-mode-hydra)
  :config
  ;; Mode maps
  (major-mode-hydra-define org-mode nil ("Movement"
                                         (("u" org-up-element "up" :exit nil)
                                          ("n" org-next-visible-heading "next visible heading" :exit nil)
                                          ("l" org-next-link "next link" :exit nil)
                                          ("L" org-previous-link "previous link" :exit nil)
                                          ("b" org-next-block "next block" :exit nil)
                                          ("B" org-prev-block "previous block" :exit nil)
                                          ("g" org-mark-ring-goto "pop mark" :exit nil))
                                         "Subtrees" (("k" org-cut-subtree "kill")
                                                     (">" org-demote-subtree "demote" :exit nil)
                                                     ("<" org-promote-subtree "promote" :exit nil)
                                                     ("N" org-narrow-to-subtree "narrow")
                                                     ("r" org-refile "refile")
                                                     ("." org-tree-to-indirect-buffer "indirect buffer")
                                                     ("'" org-id-get-create "create id"))
                                         "Inserting" (("c" citar-insert-citation "insert citation")
                                                      ("e" org-expiry-insert-expiry "insert expiry property")
                                                      ("i" org-insert-heading-respect-content "insert heading")
                                                      ("y" ash/org-paste-link "yank link" :exit t))
                                         "Opening" (("o" org-open-at-point "open at point"))
                                         "Clock" (("p" org-pomodoro "Start pomodoro")
                                                  ("P" ash/org-pomodoro-til-meeting "Start pomodoro til half hour"))
                                         "Roam" (("-" org-roam-buffer-toggle "Backlinks" :toggle t)
                                                 (";" org-roam-node-insert "add link")
                                                 (":" ash/org-roam-node-insert-immediate "add link immediately")
                                                 ("#" org-roam-tag-add "add tag")
                                                 ("a" org-roam-alias-add "add alias")
                                                 ("R" org-roam-ref-add "add ref"))))
  (major-mode-hydra-define emacs-lisp-mode nil
    ("Eval"
     (("b" eval-buffer "eval buffer")
      (";" eval-expression "eval expression")
      ("d" eval-defun "eval defun")
      ("D" edebug-defun "edebug defun")
      ("e" eval-last-sexp "eval last sexp")
      ("E" edebug-eval-last-sexp "edebug last sexp")
      ("l" ielm "ielm"))
     "Test"
     (("t" ert "prompt")
      ("T" (ert t) "all")
      ("F" (ert :failed) "failed"))
     "Doc"
     (("f" describe-function "function")
      ("v" describe-variable "variable")
      ("i" info-lookup-symbol "info lookup"))))
  (major-mode-hydra-define eshell-mode nil
    ("Movement"
     (("h" consult-history "history" :exit t)))))

(use-package hydra
  :config
  ;; define everything here
  (require 'pretty-hydra)
  (pretty-hydra-define hydra-jumps ()
    ("Jump visually"
     (("j" avy-goto-word-1 "to word" :exit t)
      ("l" avy-goto-line "to line" :exit t)
      ("c" avy-goto-char "to char" :exit t)
      ("r" avy-resume "resume" :exit t))
     "Jump via minibuffer"
     (("i" consult-imenu "imenu" :exit t)
      ("o" consult-outline "outline" :exit t))
     "Jump & go"
     (("u" ash/avy-goto-url "open url" :exit t))
     "Misc"
     (("=" hydra-all/body "back" :exit t))))
  (pretty-hydra-define hydra-structural ()
    ("Change"
     (("i" sp-change-inner "change inner" :exit t)
      ("k" sp-kill-sexp "kill sexp")
      ("]" sp-slurp-hybrid-sexp "slurp")
      ("/" sp-swap-enclusing-sexp "swap enclusing"))
     "Movement"
     (("b" sp-beginning-of-sexp "beginning of sexp")
      ("e" sp-end-of-sexp "end of sexp")
      ("d" sp-down-sexp "down sexp")
      ("e" sp-up-sexp "up sexp"))
     "Formatting"
     (("r" sp-rewrap-sexp "rewrap"))
     "Misc"
     (("=" hydra-all/body "back" :exit t))))
  (pretty-hydra-define hydra-multiple-cursors ()
    ("Mark via region"
     (("l" mc/edit-lines "edit lines" :exit t)
      ("s" mc/mark-all-in-region-regexp "mark all in region re" :exit t))
     "Mark"
     (("a" mc/mark-all-like-this "mark all" :exit t)
      ("d" mc/mark-all-dwim "mark dwim" :exit t))
     "Mark incrementally"
     (("n" mc/mark-next-like-this "mark next like this")
      ("N" mc/skip-to-next-like-this "skip to next like this")
      ("M-n" mc/unmark-next-like-this "unmark next like this")
      ("p" mc/mark-previous-like-this "mark previous like this")
      ("P" mc/skip-to-previous-like-this "skip to previous like this")
      ("M-p" mc/unmark-previous-like-this "unmark previous like this")
      ("L" mc/mark-next-lines "mark next lines"))
     "Insert"
     (("0" mc/insert-numbers "insert numbers" :exit t)
      ("A" mc/insert-letters "insert letters" :exit t))
     "Misc"
     (("=" hydra-all/body "back" :exit t))))
  (pretty-hydra-define hydra-expand ()
    ("Expand/Contract"
     (("e" er/expand-region "expand")
      ("c" er/contract-region "contract"))
     "Expand to..."
     (("d" er/mark-defun "defun")
      ("\"" er/mark-inside-quotes "quotes")
      ("'" er/mark-inside-quotes "quotes")
      ("p" er/mark-inside-pairs "pairs")
      ("." er/mark-method-call "call"))
     "Misc"
     (("=" hydra-all/body "back" :exit t))))
  (pretty-hydra-define hydra-ekg ()
    ("Navigation"
     (("t" ekg-show-today "today" :exit t)
      ("g" ekg-show-tag :exit t))
     "Capture"
     (("c" ekg-capture)
      ("u" ash/capture-literature-note))))
  (pretty-hydra-define hydra-straight ()
    ("Package specific"
     (("c" straight-check-package "check" :exit t)
      ("n" straight-normalize-package "normalize" :exit t)
      ("r" straight-rebuild-package "rebuild" :exit t)
      ("p" straight-pull-package "pull" :exit t))
     "All packages"
     (("C" straight-check-all "check" :exit t)
      ("N" straight-normalize-all "normalize" :exit t)
      ("R" straight-rebuild-all "rebuild" :exit t)
      ("P" straight-pull-all "pull" :exit t))
     "State"
     (("v" straight-freeze-versions "freeze" :exit t)
      ("t" straight-thaw-versions "thaw" :exit t)
      ("d" straight-prune-build "prune" :exit t))))
  (pretty-hydra-define hydra-yas ()
    ("Snippets"
     (("n" yas-new-snippet "new" :exit t)
      ("r" yas-reload-all "reload" :exit t)
      ("v" yas-visit-snippet-file "visit" :exit t))
     "Movement"
     (("f" yas-next-field "forward field" :exit nil)
      ("b" yas-prev-field "previous field" :exit nil))))
  (pretty-hydra-define hydra-flycheck ()
    ("Movement"
     (("n" flymake-goto-next-error "next error")
      ("p" flymake-goto-prev-error "previous error")
      ("d" flymake-goto-diagnostic "diagnostic")
      ("<" flycheck-previous-error "previous flycheck error")
      (">" flycheck-next-error "next flycheck error")
      ("l" flycheck-list-errors "list")
      ("." consult-flymake))
     "Display"
     (("." flymake-show-diagnostic "show diagnostic")
      ("B" flymake-show-diagnostics-buffer "diagnostics buffers"))
     "Misc"
     (("=" hydra-all/body "back" :exit t))))
  ;; notmuch is too specialized to be set up here, it varies from machine to
  ;; machine. At some point I should break it down into the general &
  ;; specialized parts.
  (defun ash/inbox ()
    (interactive)
    (notmuch-search "tag:inbox" t))
  (pretty-hydra-define hydra-mail ()
    ("Search"
     (("s" notmuch-search "search" :exit t)
      ("h" consult-notmuch "incremental search" :exit t))
     "Application"
     (("n" notmuch-hello "notmuch" :exit t)
      ("i" ash/inbox "inbox" :exit t)
      ("c" notmuch-mua-new-mail "compose" :exit t))
     "Misc"
     (("=" hydra-all/body "back" :exit t))))
  (pretty-hydra-define hydra-org-main ()
    ("Misc"
     (("a" org-agenda "agenda" :exit t)
      ("c" org-capture "capture" :exit t))
     "Links"
     (("s" org-store-link "store" :exit t))))
  (pretty-hydra-define hydra-find ()
    ("In-Buffer"
     (("i" consult-imenu "imenu" :exit t)
      ("m" consult-mark "mark rings" :exit t)
      ("o" consult-multi-occur "occur" :exit t)
      ("e" consult-flycheck "errors" :exit t)
      ("l" consult-goto-line "line" :exit t))
     "Other"
     (("r" consult-ripgrep "grep" :exit t)
      ("b" consult-bookmark "bookmark" :exit t)
      ("R" consult-register "register" :exit t)
      ("C" consult-complex-command "complex command" :exit t))))
  (pretty-hydra-define hydra-all
    (:quit-key "q" :title "All")
    ("Applications"
     (("m" hydra-mail/body "mail" :exit t)
      ("o" hydra-org-main/body "org" :exit t)
      ("k" hydra-ekg/body "ekg" :exit t)
      ("S" hydra-straight/body "straight" :exit t)
      ("g" magit-status "magit" :exit t)
      ("!" ash/el-secretario-daily-review "secretary" :exit t))
     "Editing"
     (("s" hydra-structural/body  "structural" :exit t)
      ("c" hydra-multiple-cursors/body "multiple cursors" :exit t)
      ("e" hydra-expand/body "expand region" :exit t)
      ("y" hydra-yas/body "snippets" :exit t))
     "Movement"
     (("j" hydra-jumps/body "jumps" :exit t)
      ("E" hydra-flycheck/body "errors" :exit t)
      ("G" deadgrep "grep" :exit t))
     "Misc"
     (("f" hydra-find/body "find" :exit t))))

  (global-set-key (kbd "M-[") 'hydra-all/body)
  (global-set-key (kbd "C-c c") 'hydra-all/body)
  (global-set-key (kbd "s-c") 'hydra-all/body))
#+END_SRC

** Expansion
yassnippet is a great way to create templates and use them.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :config
  (setq-default yas-snippet-dirs `(,(expand-file-name "snippets/" user-emacs-directory)))
  (yas-reload-all)
  (yas-global-mode 1))
#+END_SRC
** Editing
*** Multiple Cursors
Multiple cursors is fun and provides quick feedback, allowing for visual
inspection of the result as you change it.  phi-search is useful for this.  But
it doesn't work on long files, so let's bind it to special-commands.
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :pin melpa
  :general)

(use-package phi-search
  :bind (("M-C-s" . phi-search)
         ("M-C-r" . phi-search-backward)))
#+END_SRC

Expand-region is useful in lots of situations to quickly select expanding or
contracting regions.
#+BEGIN_SRC emacs-lisp
(use-package expand-region)
#+END_SRC
*** Tweaks
Confession time: vi's killing up to a char is better than emacs, so let's change things.
#+begin_src emacs-lisp
(global-set-key (kbd "M-z") #'zap-up-to-char)
#+end_src
** Programming
*** Magit
#+begin_src emacs-lisp
(use-package magit
  :general ("C-x g" 'magit-status))
#+end_src
*** Programming modes
Let's assume .h files are c++, because I mostly don't program in c.
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+END_SRC

There’s a lot of really good  editing tools. Smartparens is fairly universal, so it’s nice.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :diminish ""
  :init (add-hook 'prog-mode-hook #'smartparens-strict-mode)
  :hook (org-mode . smartparens-mode)
  :config (require 'smartparens-config))
#+END_SRC

Git gutter highlights changes to files.
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :ensure t
    :config
    (global-git-gutter-mode 't)
    :diminish git-gutter-mode)
#+END_SRC

Flycheck will help check for all errors.  Taken from https://jamiecollinson.com/blog/my-emacs-config/#syntax-checking.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :custom
  (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  :config
  (add-hook 'after-init-hook 'global-flycheck-mode)
  (setq-default flycheck-highlighting-mode 'lines)
  ;; Define fringe indicator / warning levels
  (define-fringe-bitmap 'flycheck-fringe-bitmap-ball
    (vector #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00011100
            #b00111110
            #b00111110
            #b00111110
            #b00011100
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000))
  (flycheck-define-error-level 'error
    :severity 2
    :overlay-category 'flycheck-error-overlay
    :fringe-bitmap 'flycheck-fringe-bitmap-ball
    :fringe-face 'flycheck-fringe-error)
  (flycheck-define-error-level 'warning
    :severity 1
    :overlay-category 'flycheck-warning-overlay
    :fringe-bitmap 'flycheck-fringe-bitmap-ball
    :fringe-face 'flycheck-fringe-warning)
  (flycheck-define-error-level 'info
    :severity 0
    :overlay-category 'flycheck-info-overlay
    :fringe-bitmap 'flycheck-fringe-bitmap-ball
    :fringe-face 'flycheck-fringe-info))
#+END_SRC
*** Tree Sitter
This gives emacs the power to interact with the AST.
#+begin_src emacs-lisp
(use-package tree-sitter
  :config
  (global-tree-sitter-mode))
(use-package tree-sitter-langs)
#+end_src
** Help

Which-key pops up keys in a buffer when you are in the middle of a keystroke.
#+BEGIN_SRC emacs-lisp
    (use-package which-key
      :diminish
      :config (which-key-mode 1))
#+END_SRC

Helpful is a nice replacement that is more comprehensive than normal help.
Disabled right now, it doesn't work with emacs 29. Also, the current describe
functionality is pretty nice, and has useful keybindings to go quickly to
various places.
#+BEGIN_SRC emacs-lisp
  (use-package helpful :disabled
    :bind (("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)
           ("C-h h" . helpful-at-point)
           ("C-h c" . helpful-command)))
#+END_SRC
** Appearance
#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :ensure t
  :init
  (setq modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-visible-fringes t
        modus-themes-mixed-fonts t
        modus-themes-intense-standard-completions t
        modus-themes-org-agenda '((header-block . (variable-pitch scale-title))
                                  (scheduled . uniform))
        modus-themes-variable-pitch-headings t
        modus-themes-completions 'opinionated
        modus-themes-variable-pitch-ui t
        modus-themes-rainbow-headings t
        modus-themes-section-headings t
        modus-themes-scale-headings t
        modus-themes-region '(bg-only no-extend)
        modus-themes-scale-1 1.05
        modus-themes-scale-2 1.1
        modus-themes-scale-3 1.15
        modus-themes-scale-4 1.2
        modus-themes-scale-5 1.3)
  (modus-themes-load-themes)
  (modus-themes-load-operandi))
#+END_SRC

Make org prettier.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

Also, set up Org buffers to look prettier, see https://lepisma.github.io/2017/10/28/ricing-org-mode/.
#+BEGIN_SRC emacs-lisp
(setq-default org-startup-indented t
              org-bullets-bullet-list '("①" "②" "③" "④" "⑤" "⑥" "⑦" "⑧" "⑨") 
              org-ellipsis "  " ;; folding symbol
              org-pretty-entities t
              org-hide-emphasis-markers t
              ;; show actually italicized text instead of /italicized text/
              org-agenda-block-separator ""
              org-fontify-whole-heading-line t
              org-fontify-done-headline t
              org-fontify-quote-and-verse-blocks t)
#+END_SRC

Long line in emails are necessary, so let's make sure the right things
happen
#+begin_src emacs-lisp
(use-package messages-are-flowing
  :config
  (add-hook 'message-mode-hook 'messages-are-flowing-use-and-mark-hard-newlines)
  (add-hook 'message-mode-hook 'visual-line-mode))
#+end_src

But also mails should use long lines.
#+begin_src emacs-lisp
(use-package notmuch
  :hook (notmuch-show-mode . visual-line-mode))
#+end_src

Also fix the message quoting in gmail
#+begin_src emacs-lisp
(with-eval-after-load 'message
  (setq message-cite-style message-cite-style-gmail)
  (setq message-citation-line-function 'message-insert-formatted-citation-line)
  (setq message-citation-line-format "On %a, %b %e, %Y at %I:%M %p %f wrote:\n"))
#+end_src

Improve the looks of the modeline with Powerline.
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1)
  :config (setq doom-modeline-buffer-encoding nil
                doom-modeline-minor-modes nil))
#+END_SRC

Powerline needs =all-the-icons=.  After install, run =M-x all-the-icons-install-fonts=.
#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

And use variable pitch when it makes sense.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'variable-pitch-mode)
(add-hook 'notmuch-message-mode-hook #'variable-pitch-mode)
(add-hook 'notmuch-show-hook #'variable-pitch-mode)
#+end_src

*** Window management
winner-mode allows you to navigate through window configurations.
#+begin_src emacs-lisp
(winner-mode 1)
(define-key winner-mode-map (kbd "<M-left>") #'winner-undo)
(define-key winner-mode-map (kbd "<M-right>") #'winner-redo)
#+end_src
*** Darkroom
Darkroom is a distraction-free experience.  It handles margins as well as font sizes.
#+begin_src emacs-lisp
(use-package darkroom
  :hook ((notmuch-message-mode notmuch-show org-capture-mode) . darkroom-mode))
#+end_src
** Terminal
Use vterm, which is good for when you need full terminal emulation.
#+begin_src emacs-lisp
(use-package vterm
    :ensure t)
#+end_src
** Tab Bar
I use the tab bar to sort specific activies, such as mail, elfeed, and projects each into their own tab.
#+begin_src emacs-lisp
(setq tab-bar-select-tab-modifiers '(super))
#+end_src
** Mail
I've used many mail packages, but =notmuch= is a good combination of simple, suited to mail, very fast, and with a good search.
#+begin_src emacs-lisp
(use-package notmuch
  :custom (notmuch-search-oldest-first nil)
  :config (require 'notmuch))
#+end_src

Also use the dynamic completion.
#+begin_src emacs-lisp
(use-package consult-notmuch)
#+end_src
** Searching
*** deadgrep
This requires =rg= (ripgrep).
#+begin_src emacs-lisp
(use-package deadgrep)
#+end_src
* Org config
#+BEGIN_SRC emacs-lisp
(defun ash-goto-agenda (&optional _)
  (interactive)
  (let ((buf (get-buffer "*Org Agenda(l)*")))
    (if buf
        (progn (switch-to-buffer buf)
               (delete-other-windows))
      (org-agenda))))

(require 'org-tempo)

(add-hook 'org-babel-after-execute-hook
          (lambda ()
            (when org-inline-image-overlays
              (org-redisplay-inline-images))))
(setq org-clock-string-limit 80
      org-log-done t
      org-agenda-span 'day
      org-agenda-include-diary t
      org-deadline-warning-days 4
      org-capture-bookmark nil  ;; otherwise it sets the bookmark face.
      org-clock-idle-time 30
      org-catch-invisible-edits 'error
      org-agenda-sticky t
      org-agenda-start-with-log-mode t
      org-todo-keywords '((sequence "TODO(t)" "STARTED(s)"
                                    "WAITING(w@/!)" "DELEGATED(>@)" "|" "DONE(d)"
                                    "OBSOLETE(o)")
                          (type "PERMANENT")
                          (sequence "REVIEW(r)" "SEND(e)" "EXTREVIEW(g)" "RESPOND(p)" "SUBMIT(u)" "CLEANUP(c)"
                                    "|" "SUBMITTED(b)"))
      org-agenda-custom-commands
      '(("w" todo "WAITING" nil)
        ("n" tags-todo "+someday"
         ((org-show-hierarchy-above nil) (org-agenda-todo-ignore-with-date t)
          (org-agenda-tags-todo-honor-ignore-options t)))
        ("l" "Agenda and live tasks" ((agenda)
                                      (todo "PERMANENT")
                                      (todo "WAITING|EXTREVIEW|DELEGATED")
                                      (tags-todo "deepwork/!-WAITING-EXTREVIEW-DELEGATED")
                                      (tags-todo "collab/!-WAITING-EXTREVIEW-DELEGATED")
                                      (tags-todo "quick/!-WAITING-EXTREVIEW-DELEGATED")
                                      (tags-todo "-quick-collab-deepwork/!-WAITING-EXTREVIEW-DELEGATED"))))
      org-enforce-todo-dependencies t
      org-agenda-todo-ignore-scheduled 'future
      org-agenda-dim-blocked-tasks 'invisible
      org-agenda-tags-todo-honor-ignore-options t
      org-agenda-skip-deadline-if-done 't
      org-agenda-skip-scheduled-if-done 't
      org-src-window-setup 'other-window
      org-src-tab-acts-natively t
      org-fontify-whole-heading-line t
      org-fontify-done-headline t
      org-edit-src-content-indentation 0
      org-fontify-quote-and-verse-blocks t
      org-hide-emphasis-markers t
      org-use-sub-superscripts "{}"
      org-startup-with-inline-images t
      org-agenda-prefix-format '((agenda . " %i %-18:c%?-12t% s")
                                 (timeline . "  % s")
                                 (todo . " %i %-18:c")
                                 (tags . " %i %-18:c")
                                 (search . " %i %-18:c"))
      org-modules '(org-bbdb org-docview org-info org-jsinfo org-wl org-habit org-gnus org-habit org-inlinetask)
      org-drawers '("PROPERTIES" "CLOCK" "LOGBOOK" "NOTES")
      org-cycle-separator-lines 0
      org-blank-before-new-entry '((heading) (plain-list-item . auto))
      org-clock-into-drawer nil
      org-clock-report-include-clocking-task t
      org-clock-history-length 20
      org-extend-today-until 6
      org-read-date-prefer-future nil
      org-use-property-inheritance t
      org-refile-targets '((org-agenda-files :maxlevel . 5))
      org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-use-speed-commands t
      org-link-frame-setup '((gnus . gnus)
                             (file . find-file-other-window))
      org-speed-commands-user '(("w" . ash-org-start-work))
      org-completion-use-ido t
      org-use-fast-todo-selection t
      org-habit-show-habits t)
(org-babel-do-load-languages 'org-babel-load-languages '((shell . t)))
#+END_SRC
** Other org related packages
*** Org contrib
=org-checklist= provides useful hooks for handling checklists within tasks. I use
it to clear checklists when marking a task done.
#+begin_src emacs-lisp
(use-package org-contrib
  :config
  (require 'org-checklist)
  (require 'ol-notmuch))
#+end_src
*** org-pomodoro
To me, org-pomodoro is very effective to maintain focus.
#+BEGIN_SRC emacs-lisp
(use-package org-pomodoro
  :custom
  (org-pomodoro-manual-break t)
  (org-pomodoro-play-sounds nil)
  :config
  (defun ash/org-pomodoro-til-meeting ()
    "Run a pomodoro until the next 30 minute boundary."
    (interactive)
    (let ((org-pomodoro-length (mod (- 30 (cadr (decode-time (current-time)))) 30)))
      (org-pomodoro))))
#+END_SRC
*** emacsql-sqlite3
My sqlite no longer works, it times out.  I've found switching to this package solves the problem.
#+begin_src emacs-lisp
(use-package emacsql-sqlite3)
#+end_src
*** ekg
#+begin_src emacs-lisp
;; Required library
(use-package kv)
(use-package triples)

(use-package ekg
  :straight '(ekg :type git :host github :repo "ahyatt/ekg")
  :general
  ("<f11>" 'ekg-capture)
  :config
  (defun ash/capture-literature-note ()
    (interactive)
    (ekg--connect)
    (ekg-capture)
    (push (concat "doc/" (downcase (ash/get-current-title)))
          (ekg-note-tags ekg-note))
    (setf (ekg-note-properties ekg-note)
          `(:reference/url ,(list (ash/get-current-url))))
    (ekg-edit-display-metadata)))
#+end_src

*** Vulpea
Vulpea is a API that wraps for =org= and =org-roam= in useful ways.  We use it for various =org-roam= advanced functionality.
#+begin_src emacs-lisp
(use-package vulpea
  :ensure t
  ;; hook into org-roam-db-autosync-mode you wish to enable
  ;; persistence of meta values (see respective section in README to
  ;; find out what meta means)
  :hook ((org-roam-db-autosync-mode . vulpea-db-autosync-enable)))
#+end_src
*** Org roam
The main package:
#+begin_src emacs-lisp
(use-package org-roam
   :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam-buffer-toggle)
               ("C-c n f" . org-roam-node-find)
               ("C-c n c" . org-roam-node-capture)
               ("C-c n g" . org-roam-show-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-node-insert)))
   :init
   (setq org-roam-v2-ack t)
   (setq-default org-cite-global-bibliography '("~/org/orgcite.bib"))
   :custom
   (org-roam-node-display-template "${title}" "Fix for issue with bad completion display")
   :config
   (setq org-roam-node-display-template "${title}")
   ;; From the manual.
   (add-to-list 'display-buffer-alist
                '("\\*org-roam\\*"
                  (display-buffer-in-direction)
                  (direction . right)
                  (window-width . 0.33)
                  (window-height . fit-window-to-buffer)))
   (add-hook 'org-roam-mode-hook #'visual-line-mode)
   (defun ash/org-roam-node-is-daily (n)
     "Return epoch time represented by node if N is a daily node."
     (when (string-match (rx (seq (group (= 4 digit)) "-" (group (= 2 digit)) "-" (group (= 2 digit))))
                         (org-roam-node-title n))
       (date-to-time (org-roam-node-title n))))
   
   (defun org-roam-backlinks-sort (a b)
     "Sort A, B, with dailies last (but from most recent)."
     (let* ((da (ash/org-roam-node-is-daily (org-roam-backlink-source-node a)))
            (ta (float-time (or da
                                (org-roam-node-file-mtime (org-roam-backlink-source-node a))
                                '(0 0))))
            (db (ash/org-roam-node-is-daily (org-roam-backlink-source-node b)))
            (tb (float-time (or db (org-roam-node-file-mtime (org-roam-backlink-source-node b))
                                '(0 0)))))
       (cond ((and (null da) db) t)
             ((and (null db) da) nil)
             (t (> ta tb)))))

   (ignore-errors
       (org-roam-db-autosync-mode))
   (add-to-list 'load-path "~/.emacs.d/straight/repos/org-roam/extensions/")
   (require 'org-roam-dailies)

   ;; From https://systemcrafters.net/build-a-second-brain-in-emacs/5-org-roam-hacks/
   (defun ash/org-roam-node-insert-immediate (arg &rest args)
     (interactive "P")
     (let ((args (cons arg args))
           (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                     '(:immediate-finish t)))))
       (apply #'org-roam-node-insert args)))
   (defun ash/org-roam-dailies-find-today ()
     (interactive)
     (let ((org-roam-dailies-capture-templates
            (list (append (car org-roam-dailies-capture-templates)
                          '(:immediate-finish t)))))
       (org-roam-dailies-capture-today t)))
   (defun ash/org-roam-dailies-find-yesterday ()
     (interactive)
     (let ((org-roam-dailies-capture-templates
            (list (append (car org-roam-dailies-capture-templates)
                          '(:immediate-finish t)))))
       (org-roam-dailies-capture-yesterday 1 t)))
   (defun ash/org-roam-dailies-find-date ()
     (interactive)
     (let ((org-roam-dailies-capture-templates
            (list (append (car org-roam-dailies-capture-templates)
                          '(:immediate-finish t)))))
       (org-roam-dailies-capture-date t nil)))
   (defun ash/org-roam-node-random-no-dates (&optional other-window)
     (interactive)
     (let ((random-row (seq-random-elt
                        (seq-filter (lambda (id-file)
                                      (not (string-match-p org-roam-dailies-directory
                                                           (cl-second id-file))))
                                    (org-roam-db-query [:select [id file pos] :from nodes])))))
       (org-roam-node-visit (org-roam-node-create :id (nth 0 random-row)
                                                  :file (nth 1 random-row)
                                                  :point (nth 2 random-row))
                            other-window)))
   
   (defun ash/roam-tag-filter (tag)
     "Return function that filters based on TAG."
     (lambda (n) (member tag (org-roam-node-tags n))))

   ;; To be used in `org-roam-dailies-capture-template'.
   (defun ash/problem-org-output ()
     "Return org structure for each org-roam problem."
     (mapconcat 
      (lambda (node) (format "- [[id:%s][%s]]: " (org-roam-node-id node) (org-roam-node-title node)))
      (-filter (ash/roam-tag-filter "problem") (org-roam-node-list))
      "\n"))

   ;; Set up a new link type for org
   (require 'ol)
   (org-link-set-parameters "roam"
                            :follow #'ash/org-roam-open-link
                            :store #'ash/org-roam-store-link)
   (defun ash/org-roam-open-link (id _)
     "Visit the org-roam page TITLE."
     (org-roam-node-visit (org-roam-node-from-id id)))

   (defun ash/org-roam-store-link ()
     (when (org-roam-buffer-p)
       (let ((node (org-roam-node-at-point)))
         (org-link-store-props
          :type "roam"
          :link (format "roam:%s" (org-roam-node-id node))
          :description (org-roam-node-title node)))))

   ;; Adapted from https://systemcrafters.net/build-a-second-brain-in-emacs/5-org-roam-hacks/

   (defun ash/org-roam-add-to-today (heading text)
     "Add TEXT to today's org-roam file under HEADING."
     (save-selected-window
       ;; Even if we are just adding to an existing node, we don't want to do
       ;; anything particular when the new node is created.
       ;;
       ;; TODO: Maybe just remove my particular logging on node creation?
       (let* ((org-roam-dailies-capture-templates nil)
              (org-roam-capture-templates nil)
              (org-roam-capture-new-node-hook nil)
              (org-roam-directory (expand-file-name org-roam-dailies-directory org-roam-directory)))
         (org-roam-capture- :goto nil
                            :keys "d"
                            ;; :node (org-roam-node-create)
                            :node (or (org-roam-node-from-title-or-alias (format-time-string "%Y-%m-%d"))
                                      (org-roam-node-create))
                            :templates `(("d" "default" item ,(format "- [%%T] %s\n" text)
                                          :target (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" (,heading))
                                          :immediate-finish t
                                          :kill-buffer t
                                          :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" (,heading)))) ))))

   (defun ash/log-to-roam (text)
     "Log TEXT to the current daily roam node."
     (ash/org-roam-add-to-today "Log" text))
   
   (defun ash/org-roam-copy-todo-to-today ()
     (interactive)
     (let ((org-refile-keep t)
           (org-roam-dailies-capture-templates
            ;; won't be seen.
            `(("a" "addition" entry "%?"
               :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" ("Completed Tasks")))))
           (org-after-refile-insert-hook #'save-buffer)
           today-file
           pos)
       (save-window-excursion
         (org-roam-dailies--capture (current-time) t)
         (setq today-file (buffer-file-name))
         (setq pos (point)))

       ;; Only refile if the target file is different than the current file
       (unless (equal (file-truename today-file)
                      (file-truename (buffer-file-name)))
         (save-window-excursion 
           (save-excursion
             (org-refile nil nil (list "Completed Tasks" today-file nil pos))
             (org-refile-goto-last-stored)
             (org-delete-property "ID"))))))

   (defun ash/on-todo-state-change ()
     (when (equal org-state "DONE")
       (ash/org-roam-copy-todo-to-today)))

   (defun ash/log-org-roam-node-creation ()
     (save-excursion
       (let ((node (org-roam-node-at-point)))
         (when (and
                (not (string-match org-roam-dailies-directory org-roam-directory))
                (not (org-roam-dailies--daily-note-p (org-roam-node-file node))))
           (ash/log-to-roam (format "Created %s" (org-link-make-string
                                                  (format "roam:%s" (org-roam-node-id node))
                                                  (org-roam-node-title node))))))))
   (add-to-list 'org-after-todo-state-change-hook #'ash/on-todo-state-change)

   (defun ash/org-roam-tag-search ()
     (interactive)
     (let ((org-roam-node-display-template "${tags:10} ${title}"))
       (org-roam-node-open
        (org-roam-node-read nil nil nil t "Tag: "))))

   (defun ash/org-roam-complete-tag (tag)
     (org-roam-node-open (org-roam-node-read nil (lambda (n) (member tag (org-roam-node-tags n))) nil t (concat (s-upcase tag) ": "))))

   (defun ash/org-roam-node-find-idea ()
     (interactive)
     (ash/org-roam-complete-tag "idea"))

   (defun ash/org-roam-node-find-concept ()
     (interactive)
     (ash/org-roam-complete-tag "concept"))

   (defun ash/org-roam-node-find-person ()
     (interactive)
     (ash/org-roam-complete-tag "person"))

   (defun ash/org-roam-node-find-resource ()
     (interactive)
     (ash/org-roam-complete-tag "resource"))

   (defun ash/org-roam-node-find-project ()
     (interactive)
     (ash/org-roam-complete-tag "project"))

   
   ;; When new org-roam nodes are created, note it.

   ;; Unfortunately, this isn't a good place to put it - not enough is set up before the hook.
   
   ;; (add-hook 'org-roam-capture-new-node-hook
   ;; #'ash/log-org-roam-node-creation)
   )
#+end_src

My quest to actually get new nodes logged seems to be stuck, I think I need to
fix this in =org-roam= itself, so it has a better hook.

And if you're using org-roam you probably want to use org-deft to search it.
#+begin_src emacs-lisp
(use-package deft
  :after org
  :custom
  (deft-recursive t)
  (deft-use-filter-string-for-filename t)
  (deft-default-extension "org")
  (setq-default deft-strip-summary-regexp ":PROPERTIES:\n\\(.+\n\\)+:END:\n"
                deft-use-filename-as-title t))
#+end_src

And =org-roam-ui= is a good interface:
#+begin_src emacs-lisp
(use-package org-roam-ui
  :straight
    (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    :after org-roam
    ;; normally we'd recommend hooking org-roam-ui after org-roam, but since
    ;; org-roam does not have a hookable mode anymore, you're advised to
    ;; pick something yourself if you don't care about startup time, use
    :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start nil))
#+end_src
**** Deeper integration =org-roam= and =org=
We want to make it possible to have =TODO= in =org-roam= nodes. There's a great set
of articles on this at
https://d12frosted.io/posts/2020-06-23-task-management-with-roam-vol1.html,
which this code is taken from.

#+begin_src emacs-lisp
(require 'vulpea)
(setq org-agenda-prefix-format
      '((agenda . " %i %(vulpea-agenda-category 12)%?-12t% s")
        (todo . " %i %(vulpea-agenda-category 12) ")
        (tags . " %i %(vulpea-agenda-category 12) ")
        (search . " %i %(vulpea-agenda-category 12) ")))

(defun vulpea-agenda-category (&optional len)
  "Get category of item at point for agenda.

Category is defined by one of the following items:

- CATEGORY property
- TITLE keyword
- TITLE property
- filename without directory and extension

When LEN is a number, resulting string is padded right with
spaces and then truncated with ... on the right if result is
longer than LEN.

Usage example:

  (setq org-agenda-prefix-format
        '((agenda . \" %(vulpea-agenda-category) %?-12t %12s\")))

Refer to `org-agenda-prefix-format' for more information."
  (let* ((file-name (when buffer-file-name
                      (file-name-sans-extension
                       (file-name-nondirectory buffer-file-name))))
         (title (vulpea-buffer-prop-get "title"))
         (category (org-get-category))
         (result
          (or (if (and
                   title
                   (string-equal category file-name))
                  title
                category)
              "")))
    (if (numberp len)
        (s-truncate len (s-pad-right len " " result))
      result)))
#+end_src

**** Citations
Citations are built into org mode, but it's nice to have a way to complete them.
#+begin_src emacs-lisp
(use-package citar
  :config
  (require 'oc)
  (setq org-cite-insert-processor 'citar
        org-cite-follow-processor 'citar
        org-cite-activate-processor 'citar)
  ;; if I don't load this, my bibliography gets cached and never refreshed.
  (require 'citar-filenotify)
  (citar-filenotify-setup '(LaTeX-mode-hook org-mode-hook)))
#+end_src
**** Exporting
We also need to make exporting better to work more naturally with the actual Roam research site.
#+begin_src emacs-lisp
(setq org-export-with-toc nil
      org-export-preserve-breaks t
      org-export-with-properties t
      org-export-with-tags nil)
#+end_src
*** Org UI tweaks
Use package =org-modern=.  We tried this before, but this time we'll make sure and tweak the fonts the get it right.  Hopefully there isn't the weird errors I saw before either.

#+begin_src emacs-lisp
(use-package org-modern
  :custom
  (org-auto-align-tags nil)
  (org-tags-column 0)
  (org-catch-invisible-edits 'show-and-error)
  (org-special-ctrl-a/e t)
  (org-insert-heading-respect-content t)
  (org-agenda-block-separator ?─)
  (org-agenda-current-time-string
   "⭠ now ─────────────────────────────────────────────────")
  :init
 (global-org-modern-mode))
#+end_src

*** org-appear
Very nice for editing within org elements - and conversely, without something
like this I find editing org elements frustrating.
#+begin_src emacs-lisp
(use-package org-appear
  :straight (org-appear :type git :host github :repo "awth13/org-appear")
  :hook (org-mode . org-appear-mode)
  :config (setq org-appear-autolinks nil
                org-appear-autosubmarkers t))
#+end_src
*** org babel packages
**** mermaid
Mermaid is a tool for drawing systems diagrams.
*NOTE*: The variable =ob-mermaid-cli-path= needs to be set in the config (because it will change from system to system).
#+begin_src emacs-lisp
(use-package ob-mermaid)
#+end_src
* Tangling-related

We need to add some functions to make dealing with this file easier.

This part is partially taken from
https://jamiecollinson.com/blog/my-emacs-config/#make-it-easy-to-edit-this-file.

#+BEGIN_SRC emacs-lisp
(defun ash/tangle-config ()
  "Tangle the config file to a standard config file."
  (interactive)
  (org-babel-tangle 0 "~/.emacs.d/init.el"))

(general-define-key :keymaps 'org-mode-map
                    :predicate '(s-contains? "emacs.org" (buffer-name))
            "C-c t" 'ash/tangle-config)

(defun ash/find-config ()
  "Edit config.org"
  (interactive)
  (find-file "~/.emacs.d/emacs.org"))
#+END_SRC
** Auto-tangling
We can just auto-tangle on save:
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
#+end_src
* Fixes
** PGP fix 
Without this, I can't open a gpg file.
#+begin_src elisp
(setq epa-pinentry-mode 'loopback)
#+end_src
* Writing
** Dictionary
#+begin_src emacs-lisp
(straight-use-package '(emacs-sdcv :type git :host github :repo "gucong/emacs-sdcv"))
(require 'sdcv-mode)
#+end_src
* Useful functions
Emacs doesn't have 64-bit-int processing except via calc. 
#+begin_src emacs-lisp
(defun ash/strdec-to-hex (n)
  "Given a decimal as a string, convert to hex.
This has to be done as a string to handle 64-bit or larger ints."
  (concat "0x" (replace-regexp-in-string "16#" "" (calc-eval `(,n calc-number-radix 16)))))
#+end_src
* Per-environment config
Most of my per-environment config done via =customize= and is in .custom.el.
However, some config is more involved, such as packages I just want in one
environment and not the others.  To that end, let's load a file that can contain
those customizations.
#+begin_src emacs-lisp
(let ((per-machine-filename "~/.emacs.d/permachine.el"))
  (when (file-exists-p per-machine-filename)
    (load-file per-machine-filename)))
#+end_src
* Tab setup
Finally, set up tabs the way I like them, so everything has its place.
#+begin_src emacs-lisp
(when (= 1 (length (tab-bar-tabs)))
  (tab-bar-new-tab)
  (tab-bar-new-tab)
  (tab-bar-new-tab)
  (tab-bar-rename-tab "org" 1)
  (tab-bar-rename-tab "ekg" 2)
  (tab-bar-rename-tab "mail" 3)
  (tab-bar-rename-tab "emacs" 4)
  (tab-bar-select-tab 1)
  (org-agenda nil "l")
  (delete-other-windows)
  (tab-bar-select-tab 2)
  (org-roam-node-random)
  (delete-other-windows)
  (delete-other-windows)
  (tab-bar-select-tab 3)
  (notmuch-hello)
  (tab-bar-select-tab 4)
  (find-file "~/.emacs.d/emacs.org"))
#+end_src
